[LESSON_FOLDER]../courses/04_STM32F0/Seccion03/L28_7SegClick_ASM/
[IMG_FOLDER]img/

[TITLE_SPANISH]Programa (ASM)
[TITLE_ENGLISH]Program (ASM)

[BLOCK_START]
[BEGIN_LIST]
[SPANISH]En este video puedes ver funcionando el programa que he hecho usando lenguaje ensamblador
[ENGLISH]On the following video you can see the program, that I have written in assembly language, running
[END_LIST]

[VIDEO_SPANISH]https://www.youtube.com/embed/I9-fs8x0o_w?rel=0
[VIDEO_ENGLISH]https://www.youtube.com/embed/I9-fs8x0o_w?rel=0

[BEGIN_LIST]
[SPANISH]La estructura del proyecto es igual que la del programa en C de la lección anterior, así que voy a centrarme en explicarte cómo está hecha cada función en ensamblador.
[ENGLISH]The structure of the project is the same as the program in C in the previous lesson, so I am going to focus on the explanation of each function in assembly language.
[END_LIST]
[BLOCK_END]

[BLOCK_START]
[BEGIN_LIST]
[SPANISH]El proyecto que he creado se llama <b>P13_Click7Seg_ASM</b>
[ENGLISH]The name of the project I have created is <b>P13_Click7Seg_ASM</b>
[END_LIST]
[IMG]01.png
[BLOCK_END]

[BLOCK_START]
[BEGIN_LIST]
[SPANISH]El fichero <b>main.c</b> llama a dos funciones en ensamblador, <b>AppClick7SegASM_fEnablePWM()</b> y <b>AppClick7SegASM_fShowNumber</b>
[ENGLISH]The file <b>main.c</b> calls 2 functions written in assembly language, <b>AppClick7SegASM_fEnablePWM()</b> and <b>AppClick7SegASM_fShowNumber</b>
[SPANISH]La primera parte del nombre <b>AppClick7SegASM</b> indica el fichero donde está definida la función y la segunda parte <b>fEnablePWM</b> el nombre de la función.
[ENGLISH]The first part of the name <b>AppClick7SegASM</b> is the file where it is defined and the second part <b>fEnablePWM</b> is the name of the function.
[END_LIST]
[IMG]02.png
[BLOCK_END]

[BLOCK_START]
[BEGIN_LIST]
[SPANISH]El fichero <b>AppClick7SegASM.s</b> contiene toda la programación en ensamblador para este proyecto.
[ENGLISH]The file <b>AppClick7SegASM.s</b> contains all the source code in assembly language for this project.
[END_LIST]
[IMG]03.png
[BEGIN_LIST]
[SPANISH]Voy a explicar cada función en ensamblador.
[ENGLISH]I am going to explain every function coded in assembly language.
[SPANISH]Pero, antes voy a explicar cómo funcionan las instrucciones <b>PUSH</b> y <b>POP</b>
[ENGLISH]But, first, I am going to explain how the instructions <b>PUSH</b> and <b>POP</b> work
[END_LIST]
[BLOCK_END]

[BLOCK_START]
[BEGIN_LIST]
[SPANISH]<b>PUSH</b> sirve para guardar el valor de múltiples registros en el <b>stack</b>.
[ENGLISH]<b>PUSH</b> is for saving the value of multiple registers to the <b>stack</b>.
[SPANISH]<b>PUSH</b> tiene como argumento una lista de registros. Los registros pueden ser de R0 a R7 y <b>LR</b> (r14).
[ENGLISH]<b>PUSH</b> has, as argument, a list of registers. The registers can be from R0 to R7 and <b>LR</b> (r14). 
[END_LIST]
[IMG]push.png
[BEGIN_LIST]
[SPANISH]<b>POP</b> sirve para restaurar los valores, que previamente guardamos en el stack con <b>PUSH</b>, en los registros.
[ENGLISH]<b>POP</b> is for restoring the registers with the values previouly saved to the <b>stack</b> with <b>PUSH</b>.
[SPANISH]<b>POP</b> tiene como argumento una lista de registros. Los registros pueden ser de R0 a R7 y <b>PC</b> (r15).
[ENGLISH]<b>POP</b> has, as argument, a list of registers. The registers can be from R0 to R7 and <b>PC</b> (r15).
[END_LIST]
[IMG]pop.png
[BLOCK_END]

[BLOCK_START]
[BEGIN_LIST]
[SPANISH]Voy a explicar <b>PUSH</b> en detalle con un ejemplo (<b>PUSH {R1,R3-R5}</b>).
[ENGLISH]I am going to explain <b>PUSH</b> in detail with an example.
[SPANISH]Aquí puedes ver la memoria RAM del STM32F0, abajo está la posición 0 (<b>Memory addr 0</b>) y arriba la posición más alta (<b>Max memory addr</b>).
[ENGLISH]Here you can see the STM32F0 RAM memory, at the bottom the position 0 (<b>Memory addr 0</b>) and at the top the highest position (<b>Max memory addr</b>). 
[END_LIST]
[IMG]04.png

[BEGIN_LIST]
[SPANISH]El Linker va a asingar una posición en memoria como el inicio del stack (<b>Beginning of stack</b>) y un tamaño máximo para el <b>stack</b>.
[ENGLISH]The linker is going to assign a position in memory as the start of the stack (<b>Beginning of stack</b>) and a maximum size for the <b>stack</b>.
[SPANISH]En la imagen he elegido una posición al azar.
[ENGLISH]In the image I have chosen a random position.
[END_LIST]
[IMG]05.png

[BEGIN_LIST]
[SPANISH]En el código de arranque del microcontrolador la dirección de comienzo del <b>stack</b> es cargada en el registro <b>SP</b> (Stack Pointer).
[ENGLISH]In the startup code of the MCU, the address of the beginning of the <b>stack</b> is loaded to the register <b>SP</b> (Stack Pointer). 
[SPANISH]El registro <b>SP</b> es realmente el registro <b>r13</b>.
[ENGLISH]The register <b>SP</b> is actually the register <b>r13</b>.
[END_LIST]
[IMG]06.png

[BEGIN_LIST]
[SPANISH]Imaginemos que queremos ejecutar la instrucción <b>PUSH {R1,R3-R5}</b>.
[ENGLISH]Let's suppose that we want to execute the instruction <b>PUSH {R1,R3-R5}</b>.
[SPANISH]La lista <b>{R1,R3-R5}</b> es equivalente a <b>{R1,R3,R4,R5}</b>.
[ENGLISH]The list <b>{R1,R3-R5}</b> is equivalent to <b>{R1,R3,R4,R5}</b>.
[END_LIST]
[IMG]07.png
[BEGIN_LIST]
[SPANISH]Al ejecutarse la instrucción <b>PUSH</b>, el valor de los registros R1,R3,R4 y R5 se ha copiado en el stack y el registro <b>SP</b> se ha decrementado en 16 (4 bytes por registro, ya que los registros son de 32 bits).
[ENGLISH]After the execution of the instruction <b>PUSH</b>, the value of the registers R1,R3,R4 and R5 have been copied to the stack and the register <b>SP</b> is decremented by 16 (4 bytes per register, because the register are 32-bit wide).
[SPANISH]El orden en el que se guardan los registros en el stack está predefinido. El registro más bajo ocupa la dirección más baja de memoria en el stack.
[ENGLISH]The order in which the registers are saved to the stack is predefined. The register with the lowest number occupies the lowest memory address in the stack.
[END_LIST]
[IMG]08.png
[BLOCK_END]

[BLOCK_START]
[BEGIN_LIST]
[SPANISH]Veamos ahora como funciona <b>POP {R1,R3-R5}</b>.
[ENGLISH]Let's see how <b>POP {R1,R3-R5}</b> works.
[SPANISH]En el stack están los valores de R1,R3,R4 y R5 que queremos volver a cargar en los registros.
[ENGLISH]In the stack you can see the values of R1,R3,R4 and R5 that we want to load back to the registers.
[SPANISH]SP está apuntando al valor de R1.
[ENGLISH]SP points at the value of R1.
[END_LIST]
[IMG]12.png
[BEGIN_LIST]
[SPANISH]Después de ejecutarse la instrucción <b>POP</b>, el valor del stack es copiado en los registros y el SP es incrementado en 16 para volver a la posición anterior a la ejecución de la instrucción <b>PUSH</b>.
[ENGLISH]After the execution of the instruction <b>POP</b>, the value of the stack is copied to the registers and SP is incremented by 16 to go back to the position prior to the execution of the instruction <b>PUSH</b>.
[END_LIST]
[IMG]13.png
[BLOCK_END]

[BLOCK_START]
[BEGIN_LIST]
[SPANISH]La función <b>AppClick7Seg_ShowNumber</b> era así en C (Ver lección anterior):
[ENGLISH]The function <b>AppClick7Seg_ShowNumber</b> was in C (see the previous lesson):
[END_LIST]

[SOURCE_CODE_EX_BEGIN]112
:code://  ---------------------------------------------
:code://  AppClick7Seg_ShowNumber
:code://  ---------------------------------------------
:code:void AppClick7Seg_ShowNumber(uint8_t _u8Number)
:code:{
:code:    ShowDigit(_u8Number % 10);
:code:    ShowDigit(_u8Number / 10);
:code:    GenerateLatch();
:code:}
[SOURCE_CODE_EX_END]

[BEGIN_LIST]
[SPANISH]Y en lenguaje ensamblador:
[ENGLISH]And in assembly language:
[END_LIST]

[SOURCE_CODE_EX_BEGIN]8
:code:/************************************************
:code:    AppClick7SegASM_fShowNumber
:code:    void AppClick7SegASM_fShowNumber(uint8_t _u8Number);
:code:************************************************/
:code:    .global AppClick7SegASM_fShowNumber
:code:    .func AppClick7SegASM_fShowNumber
:code:    .thumb_func
:code:AppClick7SegASM_fShowNumber:
:code:    PUSH    {r4,r5,r6,LR}
:key1:    ---------------------
:es__:Como vamos a usar los registros r4,r5 y r6 los guardamos en el stack. Guardamos también LR porque vamos a usar la instrucción BL para llamar a las funciones <b>fDivision</b>, <b>fShowDigit</b> y <b>fGenerateLatch</b>
:en__:As we are going to use the registers r4,r5 and r6, we save them to the stack. We save also LR because we are going to use the instruction BL to call the functions <b>fDivision</b>, <b>fShowDigit</b> and <b>fGenerateLatch</b>

:code:
:code:    mov     r4,r0       //r4 is the parameter _u8Number
:key2:    -------------
:es__:Copiamos el registro <b>r0</b>, que es el argumento <b>_u8Number</b>, en <b>r4</b>
:en__:We copy the register <b>r0</b>, that is the argument <b>_u8Number</b>, to <b>r4</b>

:code:
:code:    mov     r0,r4
:key3:    -------------
:es__:Queremos calcular <b>_u8Number/10</b>, así que vamos a llamar a la función <b>fDivision</b>. El primer argumento <b>r0</b> debe ser <b>_u8Number</b> que está en <b>r4</b>
:en__:We want to calculate <b>_u8Number/10</b>, so we have to call the function <b>fDivision</b>. The first argument <b>r0</b> must be <b>_u8Number</b> that is in <b>r4</b>

:code:    movs    r1,#10
:key4:    --------------
:es__:El segundo argumento de la función <b>fDivision</b> es el divisor (10) que debemos copiar en el registro <b>r1</b>.
:en__:The second argument of the function <b>fDivision</b> is the divider (10) that we have to copy to the register <b>r1</b>.

:code:    BL      fDivision
:key5:    -----------------
:es__:Llamamos a la función <b>fDivision</b>.
:en__:We call the function <b>fDivision</b>.

:code:    mov     r5,r0       //r5 is the tens
:key6:    -------------
:es__:La función <b>fDivision</b> devuelve el cociente de la división en <b>r0</b> y el resto en <b>r1</b>. Copiamos el cociente en el registro <b>r5</b>. Así que en <b>r5</b> están las decenas del número <b>_u8Number</b>.
:en__:The function <b>fDivision</b> returns the quotient of the division on <b>r0</b> and the remainder on <b>r1</b>. Let's copy the quotient to the register <b>r5</b>. This way, <b>r5</b> is the tens of the number <b>_u8Number</b>.

:code:    mov     r6,r1       //r6 is the ones
:key1:    -------------
:es__:Copiamos el resto en el registro <b>r6</b>. Así que en <b>r6</b> están las unidades del número <b>_u8Number</b>.
:en__:Let's copy the remainder to the register <b>r6</b>. So, <b>r6</b> is the ones of the number <b>_u8Number</b>.

:code:
:code:    mov     r0,r6
:key2:    -------------
:es__:Copiamos en <b>r0</b> ( el primer argumento de la función <b>fShowDIgit</b> ) las unidades.
:en__:Let's copy to <b>r0</b> ( the first argument of the function <b>fShowDIgit</b> ) the ones.

:code:    BL      fShowDigit
:key3:    ------------------
:es__:Y llamamos a la función <b>fShowDIgit</b> para que lo muestre en el display de la derecha.
:en__:And we call the function <b>fShowDIgit</b> in order to be shown on the right display.

:code:
:code:    mov     r0,r5
:key4:    -------------
:es__:Copiamos en <b>r0</b> ( el primer argumento de la función <b>fShowDIgit</b> ) las decenas.
:en__:Let's copy to <b>r0</b> ( the first argument of the function <b>fShowDIgit</b> ) the tens.

:code:    BL      fShowDigit
:key5:    ------------------
:es__:Y llamamos a la función <b>fShowDIgit</b> para que lo muestre en el display de la izquierda.
:en__:And we call the function <b>fShowDIgit</b> in order to be shown on the left display.

:code:
:code:    BL      fGenerateLatch
:key6:    ----------------------
:es__:Llamamos a la función <b>fGenerateLatch</b>.
:en__:We call the function <b>fGenerateLatch</b>.

:code:    
:code:    POP     {r4,r5,r6,PC}
:key1:    ---------------------
:es__:Restauramos el valor de los registros <b>r4, r5 y r6</b>. Incluyendo el registro <b>PC</b> en la instrucción <b>POP</b> copiamos en el registro <b>PC</b> el valor de <b>LR</b> previamente almacenado en el stack con <b>PUSH</b> y así retornamos de la función <b>AppClick7SegASM_fShowNumber</b>.
:en__:Let's restore the value of the registers <b>r4, r5 and r6</b>. Including the register <b>PC</b> in the instruction <b>POP</b> we copy to the register <b>PC</b> the value of <b>LR</b> previously stored to the stack with <b>PUSH</b> and this way we return from the function <b>AppClick7SegASM_fShowNumber</b>.

:code:    .endfunc
[SOURCE_CODE_EX_END]

[BEGIN_LIST]
[SPANISH]Como has podido observar, no hemos guardado en el <b>stack</b> los registros <b>r0</b> a <b>r3</b>. Estos registros según la ABI (Application Binary Interface) no hace falta guardarlos.
[ENGLISH]As you has noticed, we have not saved to the <b>stack</b> the registers from <b>r0</b> to <b>r3</b>. These register, according to the ABI (Application Binary Interface) don't need to be saved. 
[END_LIST]
[BLOCK_END]

[BLOCK_START]
[BEGIN_LIST]
[SPANISH]Esta es la instrucción <b>CMP</b> que sirve para comparar dos registros. Actualiza los flags para que luego podamos usar los saltos condicionales con la instrucción <b>B</b>.
[ENGLISH]This is the instruction <b>CMP</b> that is for comparing 2 registers. It updates the flags for later use of the conditional branches with the instruction <b>B</b>.
[END_LIST]
[IMG]CMP_02_Register.png
[BLOCK_END]

[BLOCK_START]
[BEGIN_LIST]
[SPANISH]Esta es la instrucción <b>BCC</b> que saltará si en la comparación anterior el primer operando es menor que el segundo.
[ENGLISH]This is the instruction <b>BCC</b> that will branch if, in the previous comparison, the first operand is less than the second one.
[END_LIST]
[IMG]B_01_Condition_b.png
[BLOCK_END]

[BLOCK_START]
[BEGIN_LIST]
[SPANISH]Esta es la instrucción <b>SUBS</b> que sirve para restar dos registros. 
[ENGLISH]This is the instruction <b>SUBS</b> that is for substracting 2 registers.
[SPANISH]Realiza la operación <b>Rn</b> - <b>Rm</b> y la guarda en <b>Rd</b>.
[ENGLISH]It does the operation <b>Rn</b> - <b>Rm</b> and writes the result to <b>Rd</b>. 
[END_LIST]
[IMG]SUB_03_Register.png
[BLOCK_END]

[BLOCK_START]
[BEGIN_LIST]
[SPANISH]<b>fDivision</b> es una función para calcular la división entera y el módulo.
[ENGLISH]<b>fDivision</b> is a new function to calculate the integer division and the modulo.
[SPANISH]Recibe el dividendo en el registro <b>r0</b> y el divisor en el registro <b>r1</b>.
[ENGLISH]It receives the dividend in the register <b>r0</b> and the divider in the register <b>r1</b>.
[SPANISH]Hay dos resultados de la división. El cociente lo devuelve en <b>r0</b> y el resto en <b>r1</b>.
[ENGLISH]There are 2 results from the division. The quotient is returned in <b>r0</b> and the remainder in <b>r1</b>.
[END_LIST]

[SOURCE_CODE_EX_BEGIN]37
:code:/************************************************
:code:    fDivision
:code:    Parameters:
:code:    r0 : Dividend
:code:    r1 : Divisor
:code:    Result:
:code:    r0 : Quotient
:code:    r1 : Remainder
:code:************************************************/
:code:    .global fDivision
:code:    .func fDivision
:code:    .thumb_func
:code:fDivision:
:key1:---------
:es__:El Cortex-M0 no tiene una instrucción para realizar la división. En Internet puedes encontrar varios algoritmos para calcular la división. Aquí lo voy a hacer usando bucles.
:en__:The Cortex-M0 CPU does not have a divide instruction. On Internet you can find multiple algorithms to do the trick, but here I am going to implement it by using loops.

:code:    PUSH    {r4,r5,r6,r7,LR}
:code:
:code:    //Copy parameters to working registers
:code:    mov     r4,r0       //r4 is the Dividend
:key2:    -------------
:es__:Copiamos en <b>r4</b> el dividendo de la división.
:en__:Let's copy to <b>r4</b> the dividend of the division.

:code:    mov     r5,r1       //r5 is the Divisor
:key3:    -------------
:es__:Y en <b>r5</b> el divisor de la división.
:en__:And to <b>r5</b> the divisor of the division.

:code:
:code:    movs    r6,#0       //r6 is the Quotient
:key4:    -------------
:es__:<b>r6</b> será el cociente de la división, lo inicializamos a 0.
:en__:<b>r6</b> will be the quotient of the division, we initialize it to 0.

:code:    mov     r0,r4
:key5:    -------------
:es__:La división la vamos a realizar de la siguiente manera. Copiamos en <b>r0</b> el dividendo, vamos a restarle a <b>r0</b> el valor del divisor hasta que <b>r0</b> sea menor al divisor. Cada vez que decrementemos <b>r0</b> incrementamos en 1 el cociente (<b>r6</b>).
:en__:The division is going to be implemented this way. We copy to <b>r0</b> the dividend, we substract from <b>r0</b> the value of the divisor, until <b>r0</b> is less than the divisor. Every time we decrement <b>r0</b> we have to increment the quotient (<b>r6</b>) by 1.

:code:fDivision_DivisionBegin:    
:key6:-----------------------
:es__:Este es el comienzo del bucle que realiza la división.
:en__:This is the beginning of the loop that performs the division.

:code:    cmp     r0,r5
:key1:    -------------
:es__:Comparamos <b>r0</b> con el divisor.
:en__:Compare <b>r0</b> to the divisor.

:code:    bcc     fDivision_DivisionEnd
:key2:    -----------------------------
:es__:Si <b>r0</b> es menor que el divisor, saltamos a la etiqueta <b>fDivision_DivisionEnd</b>, ya hemos terminado la operación.
:en__:If <b>r0</b> is less than the divisor, we jump to the label <b>fDivision_DivisionEnd</b>, the operation is done.

:code:fDivision_DivisionDo:    
:key3:--------------------
:es__:Este es el cuerpo del bucle.
:en__:This is the body of the loop.

:code:    adds    r6,#1
:key4:    -------------
:es__:Incrementamos en 1 el cociente de la división.
:en__:Increment the quotient of the division by 1.

:code:    subs    r0,r0,r5
:key5:    ----------------
:es__:Restamos a <b>r0</b> el valor del divisor.
:en__:Substract from <b>r0</b> the value of the divisor.

:code:    b       fDivision_DivisionBegin
:key6:    -------------------------------
:es__:Volvemos al inicio del bucle (línea 58).
:en__:Jump back to the beginning of the loop (línea 58).

:code:fDivision_DivisionEnd:    
:key1:---------------------
:es__:Cuando lleguemos aquí el bucle que realiza la división ya ha terminado.
:en__:When we reach this point, the division has completed.

:code:    mov     r7,r0       //r7 is the Remainder    
:key2:    -------------
:es__:<b>r0</b> contiene el resto de la división, lo copiamos en <b>r7</b>.
:en__:<b>r0</b> contains the remainder of the division, we copy it to <b>r7</b>.

:code:
:code:    //Copy result to returning registers
:code:    mov     r0,r6       
:key3:    -------------
:es__:<b>r0</b> es el registro donde la función devuelve el cociente. Copiamos <b>r6</b> a <b>r0</b>.
:en__:<b>r0</b> is the register where the function returns the quotient. We copy <b>r6</b> to <b>r0</b>.

:code:    mov     r1,r7
:key4:    -------------
:es__:<b>r1</b> es el registro donde la función devuelve el resto. Copiamos <b>r7</b> a <b>r1</b>.
:en__:<b>r1</b> is the register where the function returns the remainder. We copy <b>r7</b> to <b>r1</b>.

:code:    POP     {r4,r5,r6,r7,PC}
:code:    .endfunc
[SOURCE_CODE_EX_END]
[BLOCK_END]

[BLOCK_START]
[BEGIN_LIST]
[SPANISH]Esta es la instrucción <b>BEQ</b> que saltará si en la comparación anterior el primer operando es igual que el segundo.
[ENGLISH]This is the instruction <b>BEQ</b> that will branch if in the previous comparison the first operand is equal to the second one.
[END_LIST]
[IMG]B_01_Condition_beq.png
[BLOCK_END]

[BLOCK_START]
[BEGIN_LIST]
[SPANISH]Esta es la instrucción <b>LSRS</b> que desplaza el registro <b>Rm</b> a la derecha una cantidad de bits indicada por el número <b>imm5</b> y el resultado se almacena en el registro <b>Rd</b>.
[ENGLISH]This is the instruction <b>LSRS</b> that shifts the register <b>Rm</b> to the right an amount of bit indicated by the number <b>imm5</b> and the result is copied to the register <b>Rd</b>.
[END_LIST]
[IMG]LSR_01_Immediate.png
[BLOCK_END]

[BLOCK_START]
[BEGIN_LIST]
[SPANISH]La función <b>GenerateCode</b> era así en C:
[ENGLISH]The function <b>GenerateCode</b> was (in C):
[END_LIST]

[SOURCE_CODE_EX_BEGIN]84
:code://  ---------------------------------
:code://  GenerateCode
:code://  ---------------------------------
:code:void GenerateCode(uint8_t _u8Code)
:code:{
:code:    uint8_t    u8Mask    =    0x80;
:code:    uint8_t    u8Idx    =    0;
:code:    for(u8Idx=0; u8Idx<8; u8Idx++)
:code:    {
:code:        GPIO_PinState _pinState  =    GPIO_PIN_RESET;
:code:        if( _u8Code & u8Mask )
:code:        {
:code:            _pinState            =    GPIO_PIN_SET;
:code:        }
:code:        Generate01(_pinState);
:code:        u8Mask        >>=    1;
:code:    }
:code:}
[SOURCE_CODE_EX_END]

[BEGIN_LIST]
[SPANISH]Y en lenguaje ensamblador:
[ENGLISH]And in assembly language:
[END_LIST]

[SOURCE_CODE_EX_BEGIN]74
:code:/************************************************
:code:    fGenerateCode
:code:    void fGenerateCode(uint8_t _u8Code);
:code:************************************************/
:code:    .global fGenerateCode
:code:    .func fGenerateCode
:code:    .thumb_func
:code:fGenerateCode:
:key1:-------------
:es__:Esta función tiene un bucle con el que recorre los 8 bits del valor <b>_u8Code</b> a cargar en el HC595 y llama a la función <b>Generate01</b> para sacarlo por el pin de datos y generar un pulso en la señal de reloj.
:en__:This function has a loop that walks through the 8 bits of the value <b>_u8Code</b> to load to the HC595 and calls the function <b>Generate01</b> to output it on the data pin and to generate a pulse on the clock pin.

:code:    PUSH    {r4,r5,r6,r7,LR}
:code:
:code:    //Copy parameters to working registers
:code:    mov     r4,r0       //r4 is the parameter _u8Code
:key2:    -------------
:es__:<b>r4</b> es el registro donde vamos a almacenar el valor del parámetro <b>r0</b> que es el código <b>_u8Code</b>.
:en__:<b>r4</b> is the register where we store the value of the parameter <b>r0</b> that is the code <b>_u8Code</b>.

:code:    
:code:    movs    r5,#0x80    //r5 is u8Mask
:key3:    ----------------
:es__: <b>r5</b> es la máscara con un valor inicial de 0x80 que sirve para recorrer los bits de <b>_u8Code</b>. En el bucle esta variable valdrá <br>0x80 (1000 0000)<br>0x40 (0100 0000)<br>0x20 (0010 0000)<br>...<br>0x02 (0000 0010)<br>0x01 (0000 0001).
:en__: <b>r5</b> is the mask with an initial value of 0x80 that is for walking throught the bits of <b>_u8Code</b>. In the loop this variable will be <br>0x80 (1000 0000)<br>0x40 (0100 0000)<br>0x20 (0010 0000)<br>...<br>0x02 (0000 0010)<br>0x01 (0000 0001).

:code:    movs    r6,#8       //r6 is u8Idx    
:key4:    -------------
:es__:<b>r6</b> es el registro que contiene el número de veces que vamos a ejecutar el bucle (8).
:en__:<b>r6</b> is the register that contains the number of times the loop will be executed (8).

:code:fGenerateCode_BeginLoop:
:key5:-----------------------
:es__:Aquí comienza el bucle.
:en__:Here the loop starts.

:code:    cmp     r6,#0
:key6:    -------------
:es__:Si <b>r6</b> ha llegado a 0, hemos terminado de recorrer los bits de <b>_u8Code</b> y saltamos a <b>fGenerateCode_End</b> en la línea 108. Si no ha llegado a 0 continuamos en la línea 92.
:en__:When <b>r6</b> reaches 0, all the bits of <b>_u8Code</b> have been iterated and the program branches to <b>fGenerateCode_End</b> on the line 108. If it is not 0, the program continues on the line 92.

:code:    beq     fGenerateCode_End
:code:    mov     r7,r5
:key1:    -------------
:es__:En las líneas 92 a 94 hacemos un <b>and</b> de la máscara y de <b>_u8Code</b>, si es 1 saltamos a <b>fGenerateCode_1</b>, si no, saltamos a <b>fGenerateCode_0</b>.
:en__:In the lines 92 to 94 an <b>and</b> of the mask and <b>_u8Code</b> is performed, if it is 1, it branches to <b>fGenerateCode_1</b>, if not, it branches to <b>fGenerateCode_0</b>.

:code:    ands    r7,r4
:code:    cmp     r7,#0
:code:    beq     fGenerateCode_0
:code:fGenerateCode_1:
:code:    movs    r0,#1
:key2:    -------------
:es__:Para generar un 1, llamamos a la función <b>fGenerate01</b>, copiando en el argumento de la función (<b>r0</b>) el valor 1.
:en__:In order to generate a 1, we call the function <b>fGenerate01</b>, copying to the argument of the function (<b>r0</b>) the value 1.

:code:    BL      fGenerate01
:code:    b       fGenerateCode_EndLoop    
:code:fGenerateCode_0:
:code:    movs    r0,#0
:key3:    -------------
:es__:Para generar un 0, llamamos a la función <b>fGenerate01</b>, copiando en el argumento de la función (<b>r0</b>) el valor 0.
:en__:In order to generate a 0, we call the function <b>fGenerate01</b>, copying to the argument of the function (<b>r0</b>) the value 0.

:code:    BL      fGenerate01
:code:    b       fGenerateCode_EndLoop    
:code:fGenerateCode_EndLoop:
:key4:---------------------
:es__:Esta es la etiqueta donde hemos terminado la iteración del bucle y preparamos las variables para la siguiente iteración.
:en__:This is the label where the loop has completed the iteration and the variables are prepared for the next iteration.

:code:    lsrs    r5,r5,#1
:key5:    ----------------
:es__:Desplazamos a la derecha un bit el registro <b>r5</b> que es la máscara.
:en__:Shift, one bit to the right, the register <b>r5</b> that is the mask. 

:code:    subs    r6,#1
:key6:    -------------
:es__:Y decrementamos en 1 el contador de veces que se tiene que ejecutar el bucle.
:en__:And decrement by 1 the count of times left that the loop has to run.

:code:    b       fGenerateCode_BeginLoop    
:key1:    -------------------------------
:es__:Finalmente, saltamos al inicio del bucle.
:en__:Finally, branch to the beginning of the loop.

:code:fGenerateCode_End:
:code:    POP     {r4,r5,r6,r7,PC}
:code:    .endfunc
[SOURCE_CODE_EX_END]
[BLOCK_END]

[BLOCK_START]
[BEGIN_LIST]
[SPANISH]La función <b>Generate01</b> era así en C:
[ENGLISH]The function <b>Generate01</b> was (in C):
[END_LIST]

[SOURCE_CODE_EX_BEGIN]68
:code://  -------------------------------------
:code://  Generate01
:code://  -------------------------------------
:code:void Generate01(GPIO_PinState _pinState)
:code:{
:code:    HAL_GPIO_WritePin(  APP_GPIO_DATA_PORT,
:code:                        APP_GPIO_DATA_PIN,
:code:                        _pinState);
:code:    HAL_GPIO_WritePin(  APP_GPIO_CLOCK_PORT,
:code:                        APP_GPIO_CLOCK_PIN,
:code:                        GPIO_PIN_SET);
:code:    HAL_GPIO_WritePin(  APP_GPIO_CLOCK_PORT,
:code:                        APP_GPIO_CLOCK_PIN,
:code:                        GPIO_PIN_RESET);
:code:}
[SOURCE_CODE_EX_END]

[BEGIN_LIST]
[SPANISH]Y en lenguaje ensamblador:
[ENGLISH]And in assembly language:
[END_LIST]

[SOURCE_CODE_EX_BEGIN]112
:code:/************************************************
:code:    fGenerate01
:code:    void fGenerate01(uint32_t _pinState);
:code:************************************************/
:code:    .global fGenerate01
:code:    .func fGenerate01
:code:    .thumb_func
:code:fGenerate01:
:key1:-----------
:es__:La función <b>fGenerate01</b> saca un 1 o un 0 en el pin de datos y luego genera un pulso positivo en el pin de Clock.
:en__:The function <b>fGenerate01</b> output a 1 or a 0 on the data pin and generates a positive pulse on the Clock pin.

:code:    PUSH    {LR}
:code:
:code:    //Set data value
:key2:    ----------------
:es__:Vamos a poner un 1 o un 0 en el pin de datos con la función <b>fWritePin</b> (Línea 128).
:en__:A 1 or a 0 is put on the data pin with the function <b>fWritePin</b> (Line 128).

:code:    MOVS    r2,r0
:key3:    -------------
:es__:<b>r2</b> es el tercer argumento de la función <b>fWritePin</b>. Vamos a copiar en él el valor 0-1 a sacar en el pin y que está en <b>r0</b> porque es el primer parámetro de la función <b>fGenerate01</b>.
:en__:<b>r2</b> is the third argument of the function <b>fWritePin</b>. Let's copy to it the value 0-1 to output on the pin that is in <b>r0</b> because is the first parameter of the function <b>fGenerate01</b>. 

:code:    LDR     r3,=u32APP_GPIO_DATA_PORT
:key4:    ---------------------------------
:es__:Tenemos que copiar el valor de la variable <b>u32APP_GPIO_DATA_PORT</b> (que es el puerto del pin a escribir) en el registro r0 (que es el primer parámetro de la función <b>fWritePin</b>). Para ello copiamos la dirección de la variable en el registro temporal <b>r3</b>.
:en__:We have to copy the value of the variable <b>u32APP_GPIO_DATA_PORT</b> (that is the port number where to write) to the register r0 (that is the first parameter of the function <b>fWritePin</b>). For that, we copy the address of the variable to the temporal register <b>r3</b>.

:code:    LDR     r0,[r3]
:key5:    ---------------
:es__:Y copiamos el contenido de esa dirección de memoria en <b>r0</b>.
:en__:And we copy the content of that memory address to <b>r0</b>.

:code:    LDR     r3,=u32APP_GPIO_DATA_PIN
:key6:    --------------------------------
:es__:Tenemos que copiar el valor de la variable <b>u32APP_GPIO_DATA_PIN</b> (que es el pin a escribir) en el registro r1 (que es el segundo parámetro de la función <b>fWritePin</b>). Para ello copiamos la dirección de la variable en el registro temporal <b>r3</b>.
:en__:We have to copy the value of the variable <b>u32APP_GPIO_DATA_PIN</b> (that is the pin number to write) to the register r1 (that is the second parameter of the function <b>fWritePin</b>). For that, we copy the address of the variable to the temporal register <b>r3</b>.

:code:    LDR     r1,[r3]
:key1:    ---------------
:es__:Y copiamos el contenido de esa dirección de memoria en <b>r1</b>.
:en__:And copy the content of that memory address to <b>r1</b>.

:code:    BL      fWritePin
:key2:    -----------------
:es__:Llamamos a la función <b>fWritePin</b> para escribir el valor en el pin de datos.
:en__:Call the function <b>fWritePin</b> to write the value to the data pin.

:code:    
:code:    //Set Clock to 1 
:key3:    ----------------
:es__:Pone a 1 el pin de Clock.
:en__:Output a 1 on the Clock pin.

:code:    MOVS    r2,#1
:code:    LDR     r3,=u32APP_GPIO_CLOCK_PORT
:code:    LDR     r0,[r3]
:code:    LDR     r3,=u32APP_GPIO_CLOCK_PIN
:code:    LDR     r1,[r3]
:code:    BL      fWritePin
:code:    
:code:    //Set Clock to 0 
:key4:    ----------------
:es__:Pone a 0 el pin de Clock
:en__:Output a 0 on the Clock pin.

:code:    MOVS    r2,#0
:code:    LDR     r3,=u32APP_GPIO_CLOCK_PORT
:code:    LDR     r0,[r3]
:code:    LDR     r3,=u32APP_GPIO_CLOCK_PIN
:code:    LDR     r1,[r3]
:code:    BL      fWritePin
:code:    
:code:    POP     {PC}
:code:    .endfunc
[SOURCE_CODE_EX_END]
[BLOCK_END]

[BLOCK_START]
[BEGIN_LIST]
[SPANISH]La función <b>GenerateLatch</b> era así en C:
[ENGLISH]The function <b>GenerateLatch</b> was (in C):
[END_LIST]

[SOURCE_CODE_EX_BEGIN]55
:code://  ----------------------------------------
:code://  GenerateLatch
:code://  ----------------------------------------
:code:void GenerateLatch(void)
:code:{
:code:    HAL_GPIO_WritePin(  APP_GPIO_LATCH_PORT,
:code:                        APP_GPIO_LATCH_PIN,
:code:                        GPIO_PIN_SET);
:code:    HAL_GPIO_WritePin(  APP_GPIO_LATCH_PORT,
:code:                        APP_GPIO_LATCH_PIN,
:code:                        GPIO_PIN_RESET);
:code:}
[SOURCE_CODE_EX_END]

[BEGIN_LIST]
[SPANISH]Y en lenguaje ensamblador:
[ENGLISH]And in assembly language:
[END_LIST]

[SOURCE_CODE_EX_BEGIN]149
:code:/************************************************
:code:    fGenerateLatch
:code:    void fGenerateLatch( void );
:code:************************************************/
:code:    .global fGenerateLatch
:code:    .func fGenerateLatch
:code:    .thumb_func
:code:fGenerateLatch:
:key1:--------------
:es__:La función <b>fGenerateLatch</b> genera un pulso positivo en la señal de Latch.
:en__:The function <b>fGenerateLatch</b> generates a positive pulse on the Latch signal.

:code:    PUSH    {LR}
:code:    
:code:    //Set Latch to 1 
:key2:    ----------------
:es__:Pone a 1 el pin de Latch.
:en__:Output a 1 on the Latch pin.

:code:    MOVS    r2,#1
:code:    LDR     r3,=u32APP_GPIO_LATCH_PORT
:code:    LDR     r0,[r3]
:code:    LDR     r3,=u32APP_GPIO_LATCH_PIN
:code:    LDR     r1,[r3]
:code:    BL      fWritePin
:code:    
:code:    //Set Latch to 0 
:key3:    ----------------
:es__:Pone a 0 el pin de Latch.
:en__:Output a 0 on the Latch pin.

:code:    MOVS    r2,#0
:code:    LDR     r3,=u32APP_GPIO_LATCH_PORT
:code:    LDR     r0,[r3]
:code:    LDR     r3,=u32APP_GPIO_LATCH_PIN
:code:    LDR     r1,[r3]
:code:    BL      fWritePin
:code:    
:code:    POP     {PC}
:code:    .endfunc
[SOURCE_CODE_EX_END]
[BLOCK_END]

[BLOCK_START]
[BEGIN_LIST]
[SPANISH]La función <b>AppClick7Seg_EnablePWM</b> era así en C:
[ENGLISH]The function <b>AppClick7Seg_EnablePWM</b> was (in C):
[END_LIST]

[SOURCE_CODE_EX_BEGIN]45
:code://  -------------------------------------
:code://  AppClick7Seg_EnablePWM
:code://  -------------------------------------
:code:void AppClick7Seg_EnablePWM(void)
:code:{
:code:    HAL_GPIO_WritePin(APP_GPIO_PWM_PORT,
:code:                      APP_GPIO_PWM_PIN,
:code:                      GPIO_PIN_SET);
:code:}
[SOURCE_CODE_EX_END]

[BEGIN_LIST]
[SPANISH]Y en lenguaje ensamblador:
[ENGLISH]And in assembly language:
[END_LIST]

[SOURCE_CODE_EX_BEGIN]178
:code:/************************************************
:code:    AppClick7SegASM_fEnablePWM
:code:    void AppClick7SegASM_fEnablePWM( void );
:code:************************************************/
:code:    .global AppClick7SegASM_fEnablePWM
:code:    .func AppClick7SegASM_fEnablePWM
:code:    .thumb_func
:code:AppClick7SegASM_fEnablePWM:
:key1:--------------------------
:es__:En esta lección no vamos a usar PWM sino una salida digital que vamos a poner a nivel alto para que los transistores del Click conduzcan siempre, pero más adelante en el curso volveremos aquí para usar PWM.
:en__:In this lesson we are not going to use PWM but a digital output that we will set to high level in order to have the transistors in the Click board always driving, later on the course we will come back to use PWM.

:code:    PUSH    {LR}
:code:    
:code:    MOVS    r2,#1
:code:    LDR     r3,=u32APP_GPIO_PWM_PORT
:code:    LDR     r0,[r3]
:code:    LDR     r3,=u32APP_GPIO_PWM_PIN
:code:    LDR     r1,[r3]
:code:    BL      fWritePin
:key2:    -----------------
:es__:Pone a 1 el pin de PWM.
:en__:Output a 1 on the PWM pin.

:code:    
:code:    POP     {PC}
:code:    .endfunc
[SOURCE_CODE_EX_END]
[BLOCK_END]

[BLOCK_START]
[BEGIN_LIST]
[SPANISH]La función <b>fWritePin</b> :
[ENGLISH]The function <b>fWritePin</b>:
[END_LIST]

[SOURCE_CODE_EX_BEGIN]198
:code:/************************************************
:code:    fWritePin
:code:    void fWritePin( uint32_t    _u32PortBaseAddress,
:code:                    uint32_t    _u32Bit,
:code:                    uint32_t    _u32Value);
:code:************************************************/
:code:    .global fWritePin
:code:    .func fWritePin
:code:    .thumb_func
:code:fWritePin:
:key1:---------
:es__:Esta función ya la hemos visto en las lecciones 12 y 13.
:en__:This function was already explained on the lesson 12 and 13.

:code:    //r0: _u32PortBaseAddress
:code:    //r1: _u32Bit
:code:    //r2: _u32Value
:code:    MOVS    r2,r2
:code:    BEQ     fWritePin_0
:code:fWritePin_1:
:code:    STR     r1,[r0, #BSRR_OFFSET]
:code:    B       fWritePin_End
:code:fWritePin_0:
:code:    STR     r1,[r0, #BRR_OFFSET]
:code:fWritePin_End:
:code:    BX  lr
:code:    .endfunc
[SOURCE_CODE_EX_END]
[BLOCK_END]

[BLOCK_START]
[BEGIN_LIST]
[SPANISH]Esta es la instrucción <b>ADR</b> que copia en el registro <b>Rd</b> la dirección de la etiqueta <b>label</b>.
[ENGLISH]This is the instruction <b>ADR</b> that copies to the register <b>Rd</b> the address of the label <b>label</b>.
[END_LIST]
[IMG]ADR.png
[BLOCK_END]

[BLOCK_START]
[BEGIN_LIST]
[SPANISH]Esta es la instrucción <b>LDRB</b> que copia en el registro <b>Rt</b> el valor (1 byte) que está en la dirección que resulta de la suma de los registros <b>Rn</b> y <b>Rm</b>.
[ENGLISH]This is the instruction <b>LDRB</b> that copies to the register <b>Rt</b> the value (1 byte) that is at the address that results from the sum of the registers <b>Rn</b> and <b>Rm</b>.
[END_LIST]
[IMG]LDRB_02_Register.png
[BLOCK_END]

[BLOCK_START]
[BEGIN_LIST]
[SPANISH]El array en C <b>au8CodedDigits</b>:
[ENGLISH]The array in C <b>au8CodedDigits</b>:
[END_LIST]

[SOURCE_CODE_EX_BEGIN]22
:code:static uint8_t au8CodedDigits[] = { 0x7E,    //0
:code:                                    0x0A,    //1
:code:                                    0xB6,    //2
:code:                                    0x9E,    //3
:code:                                    0xCA,    //4
:code:                                    0xDC,    //5
:code:                                    0xFC,    //6
:code:                                    0x0E,    //7
:code:                                    0xFE,    //8
:code:                                    0xCE};    //9
[SOURCE_CODE_EX_END]

[BEGIN_LIST]
[SPANISH]Y en lenguaje ensamblador:
[ENGLISH]And in assembly language:
[END_LIST]

[SOURCE_CODE_EX_BEGIN]222
:code:/************************************************
:code:    fGetCode
:code:    uint8_t fGetCode(uint8_t _u8Digit);
:code:************************************************/
:code:    .global fGetCode
:code:    .func fGetCode
:code:    .thumb_func
:code:fGetCode:
:key1:--------
:es__:Esta función implementa el acceso a una tabla de datos en memoria. Recibe el índice en el registro <b>r0</b> y devuelve el valor en el mismo registro (<b>r0</b>).
:en__:This function implements the access to a data table in memory. It receives the index in the register <b>r0</b> and it returns the value in the same register (<b>r0</b>).

:code:    ADR     r1,fGetCodeTable
:key2:    ------------------------
:es__:Con la instrucción <b>ADR</b> copiamos la dirección de la tabla <b>fGetCodeTable</b> en el registro <b>r1</b>.
:en__:With the instruction <b>ADR</b> the address of the table <b>fGetCodeTable</b> is copied to the register <b>r1</b>.

:code:    LDRB    r0,[r1,r0]
:key3:    ----------
:es__:Con la instrucción <b>LDRB</b> copiamos un byte al registro <b>r0</b>.
:en__:With the instruction <b>LDRB</b> a byte is copied to the register <b>r0</b>.

:key4:               -------
:es__:<b>r0</b> contiene el índice del array a copiar. <b>[r1,r0]</b> es el contenido de la posición de memoria cuya dirección es la suma de <b>r0</b> y <b>r1</b>.
:en__:<b>r0</b> containes the index of the array to copy. <b>[r1,r0]</b> is the content of the memory position whose address is the sum of <b>r0</b> and <b>r1</b>.

:code:    BX  lr
:key5:    ------
:es__:Retornamos de la función.
:en__:The function returns.

:code:.align 2    //alignment is 2^2 = 4
:key6:--------
:es__:Con la directiva <b>align</b> le indicamos al ensamblador que la siguiente instrucción esté alineada, en este caso, a una dirección múltiplo de 4.
:en__:With the directive <b>align</b> we instruct the assembler that the following instruction has to be aligned, in this case, to an address multiple of 4.

:code:fGetCodeTable:
:code:    .byte   0x7E    //0
:key1:    -----
:es__:Con la directiva <b>byte</b> colocamos un byte en memoria, en este caso, el valor <b>0x7E</b>.
:en__:With the directive <b>byte</b> a byte in placed to memory, in this case, the value <b>0x7E</b>.

:code:    .byte   0x0A    //1
:key2:    -----
:es__:En la siguiente posición ponemos el valor 0x0A y así todo el array.
:en__:At the next position we place the value 0x0A and this way the complete array.

:code:    .byte   0xB6    //2
:code:    .byte   0x9E    //3
:code:    .byte   0xCA    //4
:code:    .byte   0xDC    //5
:code:    .byte   0xFC    //6
:code:    .byte   0x0E    //7
:code:    .byte   0xFE    //8
:code:    .byte   0xCE    //9
:code:    .endfunc
[SOURCE_CODE_EX_END]
[BLOCK_END]

[BLOCK_START]
[BEGIN_LIST]
[SPANISH]La función <b>ShowDigit</b> era así en C:
[ENGLISH]The function <b>ShowDigit</b> was (in C):
[END_LIST]

[SOURCE_CODE_EX_BEGIN]103
:code://  ---------------------------------------------------
:code://  ShowDigit
:code://  ---------------------------------------------------
:code:void ShowDigit(uint8_t _u8Digit)
:code:{
:code:    uint8_t    u8Code    =    au8CodedDigits[_u8Digit];
:code:    GenerateCode(u8Code);
:code:}
[SOURCE_CODE_EX_END]

[BEGIN_LIST]
[SPANISH]Y en lenguaje ensamblador:
[ENGLISH]And in assembly language:
[END_LIST]

[SOURCE_CODE_EX_BEGIN]247
:code:/************************************************
:code:    fShowDigit
:code:    void fShowDigit(uint8_t _u8Digit);
:code:************************************************/
:code:    .global fShowDigit
:code:    .func fShowDigit
:code:    .thumb_func
:code:fShowDigit:
:key1:----------
:es__:La función <b>fShowDigit</b> obtiene el byte para cargar en el HC595 correspondiente al número a mostrar en el display y llama a la función <b>GenerateCode</b>. El digito a mostrar lo recibe en el registro <b>r0</b>.
:en__:This function gets the byte (to load to the HC595) corresponding to the number to show on the display and call the function <b>GenerateCode</b>. The digit to show is received in the register <b>r0</b>.

:code:    PUSH    {LR}
:code:    BL      fGetCode
:key2:    ----------------
:es__:Llamamos a la función <b>fGetCode</b>. El digito está ya en el registro <b>r0</b> y el valor a mostrar lo va a devolver en <b>r0</b>.
:en__:Call the function <b>fGetCode</b>. The digit is already in the register <b>r0</b> and the value to show is going to be returned in <b>r0</b>. 

:code:    BL      fGenerateCode   
:key3:    ---------------------
:es__:Llamamos a la función <b>fGenerateCode</b>. El código a generar ya está en el registro <b>r0</b>.
:en__:Call the function <b>fGenerateCode</b>. The code to generate is already in the register <b>r0</b>.

:code:    POP     {PC}
:code:    .endfunc
:key4:    --------
:es__:El paso de parámetros y la devolución de resultados se hace a través del registro <b>r0</b>, por lo que como ves, ha sido muy fácil y elegante hacer la llamada a las 2 funciones.
:en__:The pass of parameters and the return of results are done using the register <b>r0</b>, so as you see, it is very easy and elegant to call these 2 functions.

[SOURCE_CODE_EX_END]
[BLOCK_END]

